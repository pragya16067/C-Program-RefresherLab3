NAME : PRAGYA PRAKASH
ROLL NO. : 2016067
LAB 3 Refresher Module

I started with reading about how C performs function calling and learned that it stores the arguments on stack, in reverse order of their calling order. So, what the Assembly function had to do was to read this data, perform the operation and push the return value back on the stack.

Now, the next problem was to find out in which register names the arguments were stored. For this, I looked at many internet resources, and read up about the registers, edi, esi, edx, eax and the stack pointer rsp and the pointer rbp. Also, I learned that the value of rsp could not be altered during the function execution and hence we create a copy rbp for tackling this issue. To make my understanding more concrete, I generated the assembly code using "gcc -S sum.c " of a sum.c file I had written which contained only the function add, as was demonstrated in class.

sum.c:

int add(int a, int b) {
	return a+b;
}

I took reference from the internet and sum.s generated by the gcc command as mentioned above and then wrote my code. 

I encountered many errors. File format was not understood by gcc when I had a .asm file so I changed it to a .s file, Also the suffixes for the instructions were wrong(I understood the difference between movl and movq) , moreover, I could not read back into the stack the correct data due to confusion between eax and edx. Initially, i had thought the data would be pushed onto the stack before the beginning of the function and hance was getting the wrong output. I later realised it had to be read from esi and edi registers.

Then finally I wrote a makefile and tried to do the add(&a, &b) function too, but could not complete it, as I kept encountering Segmentation Fault.
 
